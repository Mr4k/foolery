{"version":3,"sources":["geometry/triangle.js","physics.js","game/asteroid.js","controllers/OrientationController.js","camera/transparentOccluder.js","index.js"],"names":["EPSILON","vector","x","y","z","sub","v1","v2","add","scale","s","dot","cross","len","Math","sqrt","normalize","triangle","v3","normal","id","floor","random","edges","anchor","testPoint","v","n","rayIntersectsPlane","origin","planeLike","projTowardsPlane","abs","distToPlane","coplanarPointInTriangle","pt","epsilon","e","trueSide","testSide","sign","sphereHitsTrianglePlane","r","newOrigin","sphereHitsPlane","sphereHitsLine","lineLike","lNorm","oo","ov","ol","vl","b","a","radicant","sqrtRad","s1","s2","sphereHitsEdge","edgeLike","sphereIntersectsLine","undefined","intersectionS1","intersectionS2","projS1","projS2","ret","t","sphereHitsPoint","pointLike","newPoint","sphereHitsTriangle","sphereIntersectsTriangle","minN","minT","sphereIntersectsEdge","sphereIntersectsPoint","moved","squaredDistToEdge","point","proj","min","max","diff","dist","dir","squaredDistToTrianglePlane","squaredDistToTriangle","distToTri","distanceToEdge","reduce","closest","res","module","exports","geom","require","calculateSlide","velocity","tMax","scaledV","calculateSlide2","moveAndSlide","radius","originalVelocity","triangles","stepSize","depth","kineticFriction","totalNormalForce","totalFrictionForce","updatedTotalNormalForce","getTrianglesWithinDist","vectorsToProjectAgainst","triangleIds","vel","normalForceMag","filteredTriangles","filter","tri","includes","intersection","move","console","log","slide","slideMag","frictionAmount","postFrictionSlide","updatedTotalFrictionForce","withinDist","push","finalDir","forEach","vec","calculateGravityDirection","exclusionDist","grav","minDist","_minDist","crapRand","seed","sin","generateAsteroid","THREE","SphereGeometry","vertsToNeighborsMap","i","vertices","length","set","faces","f","c","j","neighbors","Object","keys","avgLen","sum","key","multiplyScalar","verticesNeedUpdate","computeVertexNormals","calculateOrientationDeltaAxisAndAngle","oldDown","down","rawAxis","axis","angle","acos","ORIENTATION_DIRECTIONS","LEFT","FORWARD","DOWN","ORIENTATIONS","getOrientations","quaternion","map","orientation","threeOrientation","Vector3","applyQuaternion","createOrientationController","internalQuaternion","Quaternion","internalDown","getQuaternion","clone","conjugate","update","threeAxis","updateQuaternion","setFromAxisAngle","multiply","closeRenderTarget","orthoCamera","orthoScene","setup","width","height","WebGLRenderTarget","OrthographicCamera","Scene","geometry","PlaneGeometry","material","MeshBasicMaterial","texture","alphaMap","side","DoubleSide","transparent","plane","Mesh","render","renderer","scene","originalCamera","distanceToPlayer","phys","asteroid","orientationController","transparentOccluder"],"mappings":";AAAA,IAAMA,EAAU,EAEhB,SAASC,EAAOC,EAAGC,EAAGC,GACd,MAAA,CACNF,EAAGA,EACHC,EAAGA,EACHC,EAAGA,GAIL,SAASC,EAAIC,EAAIC,GACT,MAAA,CACNL,EAAEI,EAAGJ,EAAEK,EAAGL,EACVC,EAAEG,EAAGH,EAAEI,EAAGJ,EACVC,EAAEE,EAAGF,EAAEG,EAAGH,GAIZ,SAASI,EAAIF,EAAIC,GACT,MAAA,CACNL,EAAEI,EAAGJ,EAAEK,EAAGL,EACVC,EAAEG,EAAGH,EAAEI,EAAGJ,EACVC,EAAEE,EAAGF,EAAEG,EAAGH,GAIZ,SAASK,EAAMH,EAAII,GACX,MAAA,CACNR,EAAGI,EAAGJ,EAAIQ,EACVP,EAAGG,EAAGH,EAAIO,EACVN,EAAGE,EAAGF,EAAIM,GAIZ,SAASC,EAAIL,EAAIC,GACTD,OAAAA,EAAGJ,EAAIK,EAAGL,EAAII,EAAGH,EAAII,EAAGJ,EAAIG,EAAGF,EAAIG,EAAGH,EAG9C,SAASQ,EAAMN,EAAIC,GACX,MAAA,CACNL,EAAGI,EAAGH,EAAEI,EAAGH,EAAIE,EAAGF,EAAEG,EAAGJ,EACvBA,EAAGG,EAAGF,EAAEG,EAAGL,EAAII,EAAGJ,EAAEK,EAAGH,EACvBA,EAAGE,EAAGJ,EAAEK,EAAGJ,EAAIG,EAAGH,EAAEI,EAAGL,GAIzB,SAASW,EAAIP,GACLQ,OAAAA,KAAKC,KAAKJ,EAAIL,EAAIA,IAG1B,SAASU,EAAUV,GACZO,IAAAA,EAAMC,KAAKC,KAAKJ,EAAIL,EAAIA,IACvB,MAAA,CACNJ,EAAGI,EAAGJ,EAAIW,EACVV,EAAGG,EAAGH,EAAIU,EACVT,EAAGE,EAAGF,EAAIS,GAKZ,SAASI,EAASX,EAAIC,EAAIW,GACnBC,IAAAA,EAASH,EAAUJ,EAAMP,EAAIC,EAAIY,GAAKb,EAAIE,EAAIW,KAG7C,MAAA,CACNE,GAFUN,KAAKO,MAAsB,IAAhBP,KAAKQ,UAG1BhB,GAAIA,EACJC,GAAIA,EACJW,GAAIA,EACJC,OAAAA,EACAI,MAAO,CAAC,CACPC,OAAQjB,EACRkB,UAAWP,EACXQ,EAAGV,EAAUX,EAAIC,EAAIC,IACrBM,IAAKA,EAAIR,EAAIC,EAAIC,IACjBoB,EAAGX,EAAUJ,EAAMP,EAAIC,EAAIC,GAAKY,KAC9B,CACFK,OAAQN,EACRO,UAAWnB,EACXoB,EAAGV,EAAUX,EAAIE,EAAIW,IACrBL,IAAKA,EAAIR,EAAIE,EAAIW,IACjBS,EAAGX,EAAUJ,EAAMP,EAAIE,EAAIW,GAAKC,KAC9B,CACFK,OAAQlB,EACRmB,UAAWlB,EACXmB,EAAGV,EAAUX,EAAIa,EAAIZ,IACrBO,IAAKA,EAAIR,EAAIa,EAAIZ,IACjBqB,EAAGX,EAAUJ,EAAMP,EAAIa,EAAIZ,GAAKa,OAKnC,SAASS,EAAmBC,EAAQH,EAAGI,GAChCC,IAAAA,EAAmBpB,EAAImB,EAAUX,OAAQO,GAC3CZ,KAAAA,KAAKkB,IAAID,GAAoB/B,GAI1BiC,OADatB,EADAN,EAAIyB,EAAUxB,GAAIuB,GACDC,EAAUX,QAC1BY,EAGtB,SAASG,EAAwBC,EAAIlB,GAAUmB,IAAAA,EAAU,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAG,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAC7CnB,IAAAA,IAAgB,EAAhBA,EAAAA,EAASM,MAAO,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAArBc,IAAAA,EAAqB,EAAA,MACvBC,EAAW3B,EAAIN,EAAIgC,EAAEZ,UAAWY,EAAEb,QAASa,EAAEV,GAC7CY,EAAW5B,EAAIN,EAAI8B,EAAIE,EAAEb,QAASa,EAAEV,GACtCb,GAAAA,KAAK0B,KAAKD,KAAczB,KAAK0B,KAAKF,IAAaxB,KAAKkB,IAAIM,EAAWC,IAAaH,EAAS,OAAO,GAJ1C,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GAMpD,OAAA,EAKR,SAASK,EAAwBZ,EAAQH,EAAGgB,EAAGzB,GACtCX,IAAAA,EAAeW,EAAfX,GAAIa,EAAWF,EAAXE,OACNqB,EAAO1B,KAAK0B,KAAK7B,EAAIN,EAAIwB,EAAQvB,GAAKa,IACtCwB,EAAYtC,EAAIwB,EAAQpB,EAAMU,EAAQuB,EAAIF,IAE1CI,EAAkBhB,EAAmBe,EAAWjB,EAAGT,GACrD,GAAC2B,EAGDV,OAAAA,EAD4B1B,EAAIC,EAAMiB,EAAGkB,GAAkBD,GACV1B,GAAkB2B,OAAnEV,EAML,SAASW,EAAehB,EAAQH,EAAGgB,EAAGI,GAC/BH,IAAAA,EAAYtC,EAAIwB,EAAQiB,EAAStB,QACjCuB,EAAQD,EAASpB,EACjBsB,EAAKrC,EAAIgC,EAAWA,GACpBM,EAAKtC,EAAIgC,EAAWjB,GACpBwB,EAAKvC,EAAIgC,EAAWI,GACpBI,EAAKxC,EAAIe,EAAGqB,GAGZK,EAAI,GAAKH,EAAKC,EAAKC,GACnBE,EAHK1C,EAAIe,EAAGA,GAGHyB,EAAKA,EAEdG,EAAWF,EAAEA,EAAI,EAAEC,GAJfL,EAAKE,EAAKA,EAAKR,EAAIA,GAKzBY,KAAAA,EAAW,GAAXA,CAEEC,IAAAA,EAAUzC,KAAKC,KAAKuC,GACnB,MAAA,CACNE,KAAMJ,EAAIG,IAAY,EAAIF,GAC1BI,KAAML,EAAIG,IAAY,EAAIF,KAM5B,SAASK,EAAe7B,EAAQH,EAAGgB,EAAGiB,GAC/BC,IAAAA,EAAuBf,EAAehB,EAAQH,EAAGgB,EAAGiB,GACtDC,QAAyBC,IAAzBD,EAAoC,MAAO,GAEvCJ,IAAAA,EAAWI,EAAXJ,GAAIC,EAAOG,EAAPH,GAENd,EAAYtC,EAAIwB,EAAQ8B,EAASnC,QAEjCsC,EAAiBtD,EAAIC,EAAMiB,EAAG8B,GAAKb,GACnCoB,EAAiBvD,EAAIC,EAAMiB,EAAG+B,GAAKd,GAEnCqB,EAASrD,EAAImD,EAAgBH,EAASjC,GACtCuC,EAAStD,EAAIoD,EAAgBJ,EAASjC,GAEtCwC,EAAM,CACXV,GAAI,CACHW,EAAGX,EACH7B,EAAGtB,EAAIyD,EAAgBrD,EAAMkD,EAASjC,EAAGsC,KAE1CP,GAAI,CACHU,EAAGV,EACH9B,EAAGtB,EAAI0D,EAAgBtD,EAAMkD,EAASjC,EAAGuC,MAOpCC,OAHHF,EAAS,GAAKA,EAASL,EAAS9C,OAAKqD,EAAIV,QAAKK,IAC9CI,EAAS,GAAKA,EAASN,EAAS9C,OAAKqD,EAAIT,QAAKI,GAE3CK,EAGR,SAASE,EAAgBvC,EAAQH,EAAGgB,EAAG2B,GAChCC,IAAAA,EAAWjE,EAAIgE,EAAU7C,OAAQK,GACjCwB,EAAI1C,EAAIe,EAAGA,GACX0B,GAAK,EAAIzC,EAAIe,EAAG4C,GAGhBhB,EAAWF,EAAEA,EAAI,EAAEC,GAFf1C,EAAI2D,EAAUA,GAAY5B,EAAIA,GAGpCY,KAAAA,EAAW,GAAXA,CAEEC,IAAAA,EAAUzC,KAAKC,KAAKuC,GACnB,MAAA,CACNE,KAAMJ,EAAIG,IAAY,EAAIF,GAC1BI,KAAML,EAAIG,IAAY,EAAIF,KAM5B,SAASkB,EAAmB1C,EAAQH,EAAGgB,EAAGzB,GACnCuD,IAGFC,EAHED,EAA2B/B,EAAwBZ,EAAQH,EAAGgB,EAAGzB,GAEnEyD,EAAO,SAIsBb,IAA7BW,GAA0CA,EAA2B,IACxEE,EAAOF,EACPC,EAAOxD,EAASE,QATkC,IAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAYrCF,IAAAA,IAAgB,EAAhBA,EAAAA,EAASM,MAAO,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAArBc,IAAAA,EAAqB,EAAA,MACvBsC,EAAuBjB,EAAe7B,EAAQH,EAAGgB,EAAGL,QAC1BwB,IAA5Bc,EAAqBnB,IAAoBmB,EAAqBnB,GAAGW,GAAK,GAAKQ,EAAqBnB,GAAGW,EAAIO,IAC1GA,EAAOC,EAAqBnB,GAAGW,EAC/BM,EAAOzD,EAAU2D,EAAqBnB,GAAG7B,SAEVkC,IAA5Bc,EAAqBlB,IAAoBkB,EAAqBlB,GAAGU,GAAK,GAAKQ,EAAqBlB,GAAGU,EAAIO,IAC1GA,EAAOC,EAAqBlB,GAAGU,EAC/BM,EAAOzD,EAAU2D,EAAqBlB,GAAG9B,IAGpCiD,IAAAA,EAAwBR,EAAgBvC,EAAQH,EAAGgB,EAAGL,GACxDuC,QAA0Bf,IAA1Be,GAAuCA,EAAsBpB,IAAM,GAAKoB,EAAsBpB,GAAKkB,EAAM,CACtGG,IAAAA,EAAQrE,EAAIC,EAAMiB,EAAGkD,EAAsBpB,IAAK3B,GACtD6C,EAAOE,EAAsBpB,GAC7BiB,EAAOzD,EAAUX,EAAIwE,EAAOxC,EAAEb,SAE3BoD,QAA0Bf,IAA1Be,GAAuCA,EAAsBnB,IAAM,GAAKmB,EAAsBnB,GAAKiB,EAAM,CACtGG,IAAAA,EAAQrE,EAAIC,EAAMiB,EAAGkD,EAAsBnB,IAAK5B,GACtD6C,EAAOE,EAAsBnB,GAC7BgB,EAAOzD,EAAUX,EAAIwE,EAAOxC,EAAEb,WAhCmB,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GAoC/C,GAACiD,EACE,MAAA,CACNN,EAAGO,EACH/C,EAAG8C,GAIL,SAASK,EAAkBC,EAAOpB,GAC3BW,IAAAA,EAAWjE,EAAI0E,EAAOpB,EAASnC,QACjCwD,EAAOrE,EAAI2D,EAAUX,EAASjC,GAElCsD,EAAOlE,KAAKmE,IAAInE,KAAKoE,IAAI,EAAGF,GAAOrB,EAAS9C,KAEtCsE,IAAAA,EAAO9E,EAAIiE,EAAU7D,EAAMkD,EAASjC,EAAGsD,IACtC,MAAA,CACNI,KAAMzE,EAAIwE,EAAMA,GAChBE,IAAKrE,EAAUmE,IAIjB,SAASG,EAA2BP,EAAO9D,GAAUmB,IAAAA,EAAU,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EACxDkC,EAAWjE,EAAI0E,EAAO9D,EAASX,IAC/B0E,EAAO3E,EAAIiE,EAAU7D,EAAMQ,EAASE,OAAQR,EAAI2D,EAAUrD,EAASE,UACnEgE,EAAO9E,EAAIiE,EAAUU,GAEvB9C,GAAAA,EAAwB1B,EAAIwE,EAAM/D,EAASX,IAAKW,EAAUmB,GAAU,MAAO,CAC9EgD,KAAMzE,EAAIwE,EAAMA,GAChBE,IAAKrE,EAAUmE,IAMjB,SAASI,EAAsBR,EAAO9D,GAC/BuE,IAAAA,EAAYF,EAA2BP,EAAO9D,GAE9CwE,EAAiBxE,EAASM,MAAMmE,OAAO,SAACC,EAAStD,GAChDuD,IAAAA,EAAMd,EAAkBC,EAAO1C,GACjC,OAACsD,GAAWC,EAAIR,KAAOO,EAAQP,KAAaQ,EAEzCD,GACL,MAICH,OAAAA,KAAeC,GAAkBD,EAAUJ,KAAOK,EAAeL,MAAcI,EAC5EC,EAGRI,OAAOC,QAAU,CAChBtF,IAAAA,EACAH,IAAAA,EACAI,MAAAA,EACAE,IAAAA,EACAC,MAAAA,EACAX,OAAAA,EACAe,UAAAA,EACAC,SAAAA,EACAW,mBAAAA,EACAM,wBAAAA,EACAO,wBAAAA,EACAI,eAAAA,EACAa,eAAAA,EACAU,gBAAAA,EACAG,mBAAAA,EACAgB,sBAAAA,EACAT,kBAAAA,EACAQ,2BAAAA;;AC/SD,IAAMS,EAAOC,QAAQ,uBACfhG,EAAU,EAEhB,SAASiG,EAAeC,EAAU/B,EAAGgC,EAAMhF,GACpCiF,IAAAA,EAAUL,EAAKtF,MAAMyF,EAAUC,EAAOhC,GACrC4B,OAAAA,EAAKvF,IAAI4F,EAASL,EAAKtF,MAAMU,GAAS4E,EAAKpF,IAAIyF,EAASjF,KAGhE,SAASkF,EAAgBH,EAAU/B,EAAGgC,EAAMhF,GACrCiF,IAAAA,EAAUL,EAAKtF,MAAMyF,EAAUC,EAAOhC,GACrC4B,OAAAA,EAAKvF,IAAI4F,EAASL,EAAKtF,MAAMU,GAASL,KAAKmE,IAAIc,EAAKpF,IAAIyF,EAASjF,GAAS,KAGlF,SAASmF,EAAazE,EAAQ0E,EAAQC,EAAkBC,GAAWC,IAAAA,EAAW,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAGC,EAAQ,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAGC,EAAkB,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GAAKC,EAAmB,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAAE3G,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAAK0G,EAAqB,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAAE5G,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAC7LuG,GAAU,IAAVA,EAAa,MAAO,CAAEhE,UAAWd,EAAQgF,iBAAAA,EAAkBC,mBAAAA,GAK3DC,IAYAtC,EAZAsC,EAA0BF,EAEmBG,EAAAA,EAAuBnF,EAAQ4E,EAAWF,EAAS,GAA5FU,EAAAA,EAAAA,wBAAyBC,EAAAA,EAAAA,YAC3BhB,EAAWe,EAAwBvB,OAAO,SAACyB,EAAKhG,GAC/CiG,IAAAA,GAAkBrB,EAAKpF,IAAIQ,EAAQgG,GAElCd,OADPU,EAA0BhB,EAAKvF,IAAIuF,EAAKtF,MAAMU,EAAQiG,GAAiBL,GAChEV,EAAgBc,EAAK,EAAGT,EAAUvF,IACvCqF,GACGa,EAAoBZ,EAAUa,OAAO,SAAAC,GAAO,OAACL,EAAYM,SAASD,EAAInG,MAGxEsD,EAAO,KAjB2L,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAoBjL2C,IAAAA,IAAmB,EAAnBA,EAAAA,EAAmB,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAA/BpG,IAAAA,EAA+B,EAAA,MACjCwG,EAAe1B,EAAKxB,mBAAmB1C,EAAQqE,EACpDK,EAAQtF,GACLwG,GAAgBA,EAAatD,GAAK,GAAKsD,EAAatD,EAAIO,IAC3DD,EAAOgD,EAAa9F,EACpB+C,EAAO+C,EAAatD,IAzBgL,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GA6BtMO,EAAO5D,KAAKmE,IAAInE,KAAKoE,IAAIR,EAAO1E,EAAS,GAAI0G,GAEvCgB,IAAAA,EAAO3B,EAAKvF,IAAIqB,EAAQkE,EAAKtF,MAAMyF,EAAUxB,IAG/C,GAFJiD,QAAQC,IAAI,CAAEjF,UAAW+E,EAAMb,iBAAkBE,EAAyBD,mBAAAA,KAErErC,EAAM,MAAO,CAAE9B,UAAW+E,EAAMb,iBAAkBE,EAAyBD,mBAAAA,GAE1Ee,IAAAA,EAAQ5B,EAAeC,EAAUxB,EAAMgC,EAAUjC,GAIjD2C,EAAiBtG,KAAKkB,IAAI+D,EAAKpF,IAAI8D,EAAMyB,KAAc,EAAIxB,GACjEqC,EAA0BhB,EAAKvF,IAAIuG,EAAyBhB,EAAKtF,MAAMgE,EAAM2C,IAEvEU,IAAAA,EAAWhH,KAAKC,KAAKgF,EAAKpF,IAAIkH,EAAOA,IACrCE,EAAiBjH,KAAKoE,IAAI4C,EAAWV,EAAiBR,EAAiB,IAAmB,IAAbkB,EAAiB,EAAIA,GAClGE,EAAoBjC,EAAKtF,MAAMoH,EAAOE,GACtCE,EAA4BlC,EAAKvF,IACtCsG,EACAf,EAAKtF,MAAMoH,IAAS,EAAIE,KAGlBzB,OAAAA,EAAaoB,EAAMnB,EAAQyB,EAAmBvB,EAAWC,EAAUC,EAAQ,EAAGC,EAAiBG,EAAyBkB,GAGhI,IAAMjB,EAAyB,SAACnF,EAAQ4E,EAAWyB,GAAezB,OAAAA,EAAUf,OAAO,SAA2C6B,EAAAA,GAAxCN,IAAAA,EAAAA,EAAAA,wBAAyBC,EAAAA,EAAAA,YAC1GhD,EAAM6B,EAAKR,sBAAsB1D,EAAQ0F,GACzC,IAACrD,EAAK,MAAO,CAChB+C,wBAAAA,EACAC,YAAAA,GAGO9B,IAAAA,EAAclB,EAAdkB,KAAMC,EAAQnB,EAARmB,IAEVD,GAAAA,EAAO8C,EAAaA,EAAY,CACnChB,EAAYiB,KAAKZ,EAAInG,IAEjBgH,IAAAA,EAAW/C,EACf4B,EAAwBoB,QAAQ,SAAAC,GACzBtD,IAAAA,EAAOlE,KAAKmE,IAAIc,EAAKpF,IAAIyH,EAAUE,GAAM,GAC/CF,EAAWrC,EAAKvF,IAAI4H,EAAUrC,EAAKtF,MAAM6H,GAAMtD,MAE7B,IAAfoD,EAASlI,GAA0B,IAAfkI,EAASjI,GAA0B,IAAfiI,EAAShI,GACpD6G,EAAwBkB,KAAKpC,EAAK/E,UAAUoH,IAIvC,MAAA,CACNnB,wBAAAA,EACAC,YAAAA,IAEC,CACFD,wBAAyB,GACzBC,YAAa,MAId,SAASqB,EAA0B1G,EAAQ4E,GAAW+B,IAAAA,EAAgB,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,IAC1C/B,EAAAA,EAAUf,OAAO,SAAoB6B,EAAAA,GAAjBkB,IAAAA,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,QAChDxE,EAAM6B,EAAKR,sBAAsB1D,EAAQ0F,GACzC,IAACrD,EAAK,MAAO,CAAEuE,KAAAA,EAAMC,QAAAA,GAEjBtD,IAAAA,EAAclB,EAAdkB,KAAMC,EAAQnB,EAARmB,IAEVD,OAAAA,EAAOoD,EAAgBA,IAAkBpD,EAAa,CAAEqD,KAAAA,EAAMC,QAAAA,GAE9DtD,EAAOsD,EAAgB,CAAED,KAAAA,EAAMC,QAAAA,GAiB5B,CAAED,KAFTA,EAAOpD,EAEQqD,QAAStD,IACtB,CAAEqD,KAAM1C,EAAK9F,OAAO,EAAG,EAAG,GAAIyI,QAAS,MA1BlCD,EAAAA,EAAAA,KAAME,EAAAA,SA2BVF,OAAW,IAAXA,EAAKvI,GAAsB,IAAXuI,EAAKtI,GAAsB,IAAXsI,EAAKrI,EAAgBqI,EAElD1C,EAAKtF,MAAMsF,EAAK/E,UAAUyH,IAAQ,GAG1C5C,OAAOC,QAAU,CAChBG,eAAAA,EACAK,aAAAA,EACAP,KAAAA,EACAwC,0BAAAA;;ACxID,SAASK,EAASC,GACV,OAAC/H,KAAKgI,IAAID,GAAQ,GAAK,EAG/B,SAASE,EAAiBC,EAAOzC,GAC1BR,IAAAA,EAAO,IAAIiD,EAAMC,eAAe1C,EAAQ,GAAI,IAElD2C,oBAAsB,GACjB,IAAA,IAAIC,EAAI,EAAGA,EAAIpD,EAAKqD,SAASC,OAAQF,GAAG,EAAG,CAC/CD,oBAAoBf,KAAK,IACrB1H,IAAAA,EAAwB,IAAhBK,KAAKQ,SAAiB,GAClCb,GAASA,EAAQA,EACjBsF,EAAKqD,SAASD,GAAGG,IAChBvD,EAAKqD,SAASD,GAAGjJ,EAAIO,EACrBsF,EAAKqD,SAASD,GAAGhJ,EAAIM,EACrBsF,EAAKqD,SAASD,GAAG/I,EAAIK,GAXiB,IAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAc1BsF,IAAAA,IAAY,EAAZA,EAAAA,EAAKwD,MAAO,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAAjBC,IAAAA,EAAiB,EAAA,MACzBN,oBAAoBM,EAAEnG,GAAGmG,EAAEpG,IAAK,EAChC8F,oBAAoBM,EAAEnG,GAAGmG,EAAEC,IAAK,EAChCP,oBAAoBM,EAAEpG,GAAGoG,EAAEnG,IAAK,EAChC6F,oBAAoBM,EAAEpG,GAAGoG,EAAEC,IAAK,EAChCP,oBAAoBM,EAAEC,GAAGD,EAAEnG,IAAK,EAChC6F,oBAAoBM,EAAEC,GAAGD,EAAEpG,IAAK,GApBO,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GAuBxCuE,QAAQC,IAAI,MAAOsB,qBAEd,IAAA,IAAIQ,EAAI,EAAGA,EAAI,EAAGA,IACjB,IAAA,IAAIP,EAAI,EAAGA,EAAIpD,EAAKqD,SAASC,OAAQF,GAAG,EAAG,CACzCQ,IAAAA,EAAYC,OAAOC,KAAKX,oBAAoBC,IAC9CW,EAASH,EAAUjE,OAAO,SAACqE,EAAKC,GAC5BD,OAAAA,EAAMhE,EAAKqD,SAASY,GAAKX,UAC9B,IAA2B,IAArBM,EAAUN,OAAe,EAAIM,EAAUN,QAChD1B,QAAQC,IAAIkC,GACZ/D,EAAKqD,SAASD,GAAKpD,EAAKqD,SAASD,GAAGnI,YAAYiJ,eAAeH,GAM1D/D,OAFPA,EAAKmE,oBAAqB,EAC1BnE,EAAKoE,uBACEpE,EAGRF,OAAOC,QAAU,CAChBiD,iBAAAA;;AC5CD,SAASqB,EAAsCC,EAASC,GAEhDC,IAAAA,EAAUxE,KAAKnF,MAAM0J,EAAMD,GAC7BvJ,GAAAA,KAAKkB,IAAI+D,KAAKpF,IAAI4J,EAASA,IAAY,KAGlC,MAAA,CAAEC,KAFIzE,KAAK/E,UAAUuJ,GAEbE,MADD3J,KAAK4J,KAAK3E,KAAKpF,IAAI2J,EAAMD,KAO3C,IAAMM,EAAyB,CAC7BC,KAAM,EACNC,QAAS,EACTC,KAAM,GAGFC,EAAe,CACnB,CAAE7K,EAAG,EAAGC,EAAG,EAAGC,EAAG,GACjB,CAAEF,EAAG,EAAGC,GAAI,EAAGC,EAAG,GAClB,CAAEF,EAAG,EAAGC,EAAG,EAAGC,EAAG,IAInB,SAAS4K,EAAgBhC,EAAOiC,GACvBF,OAAAA,EAAaG,IAAI,SAAAC,GAChBC,IAAAA,EAAmB,IAAIpC,EAAMqC,QAAQF,EAAYjL,EAAGiL,EAAYhL,EAAGgL,EAAY/K,GAE9EgL,OADPA,EAAiBE,gBAAgBL,GAC1BG,IAIX,SAASG,EAA4BvC,GAC7BwC,IAAAA,EAAqB,IAAIxC,EAAMyC,WACjCC,EAAeX,EAAaJ,EAAuBG,MAChD,MAAA,CACLa,cAAe,WAAMH,OAAAA,EAAmBI,QAAQC,aAChDC,OAAQ,SAAAxB,GACApG,IAAAA,EAAMkG,EACVsB,EACApB,GAEE,GAACpG,EAAD,CAEIsG,IAAAA,EAAgBtG,EAAhBsG,KAAMC,EAAUvG,EAAVuG,MACRsB,EAAY,IAAI/C,EAAMqC,QAAQb,EAAKtK,EAAGsK,EAAKrK,EAAGqK,EAAKpK,GAEnD4L,EAAmB,IAAIhD,EAAMyC,WACnCO,EAAiBC,iBAAiBF,EAAWtB,GAE7Ce,EAAmBU,SAASF,GAC5BN,EAAepB,KAKrBzE,OAAOC,QAAU,CACfyF,4BAAAA,EACAP,gBAAAA,EACAL,uBAAAA;;AC9DF,IAAIwB,EACAC,EACAC,EAEJ,SAASC,EAAMtD,EAAOuD,EAAOC,GACzBL,EAAoB,IAAInD,EAAMyD,kBAAkBF,EAAOC,EAAQ,IAC/DJ,EAAc,IAAIpD,EAAM0D,oBAAoB,EAAG,EAAG,GAAI,EAAG,EAAG,IAC5DL,EAAa,IAAIrD,EAAM2D,MACjBC,IAAAA,EAAW,IAAI5D,EAAM6D,cAAe,EAAG,GACvCC,EAAW,IAAI9D,EAAM+D,kBAAmB,CAC1C7B,IAAKiB,EAAkBa,QACvBC,SAAUd,EAAkBa,QAC5BE,KAAMlE,EAAMmE,WACZC,aAAa,IAEXC,EAAQ,IAAIrE,EAAMsE,KAAMV,EAAUE,GACxCT,EAAW7L,IAAI6M,GAGnB,SAASE,EAAOvE,EAAOwE,EAAUC,EAAOC,EAAgBC,GAWpDH,EAASD,OAAOE,EAAOC,GAM3B7H,OAAOC,QAAU,CACbwG,MAAAA,EACAiB,OAAAA;;ACtCJ,IAAMK,EAAO5H,QAAQ,gBACfD,EAAOC,QAAQ,0BAEf6H,EAAW7H,QAAQ,sBACnB8H,EAAwB9H,QAAQ,uCAEhC+H,EAAsB/H,QAAQ,gCAEpCH,OAAOC,QAAU,CAChB8H,KAAAA,EACA7H,KAAAA,EACA8H,SAAAA,EACAC,sBAAAA,EACAC,oBAAAA","file":"index.js","sourceRoot":"../js","sourcesContent":["const EPSILON = 0.000000;\n\nfunction vector(x, y, z) {\n\treturn {\n\t\tx: x,\n\t\ty: y,\n\t\tz: z,\n\t}\n}\n\nfunction sub(v1, v2) {\n\treturn {\n\t\tx:v1.x-v2.x,\n\t\ty:v1.y-v2.y,\n\t\tz:v1.z-v2.z,\n\t}\n}\n\nfunction add(v1, v2) {\n\treturn {\n\t\tx:v1.x+v2.x,\n\t\ty:v1.y+v2.y,\n\t\tz:v1.z+v2.z,\n\t}\n}\n\nfunction scale(v1, s) {\n\treturn {\n\t\tx: v1.x * s,\n\t\ty: v1.y * s,\n\t\tz: v1.z * s,\n\t}\n}\n\nfunction dot(v1, v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfunction cross(v1, v2) {\n\treturn {\n\t\tx: v1.y*v2.z - v1.z*v2.y,\n\t\ty: v1.z*v2.x - v1.x*v2.z,\n\t\tz: v1.x*v2.y - v1.y*v2.x,\n\t}\n}\n\nfunction len(v1) {\n\treturn Math.sqrt(dot(v1, v1));\n}\n\nfunction normalize(v1) {\n\tconst len = Math.sqrt(dot(v1, v1));\n\treturn {\n\t\tx: v1.x / len,\n\t\ty: v1.y / len,\n\t\tz: v1.z / len,\n\t}\n}\n\n// TODO make this function more efficient\nfunction triangle(v1, v2, v3) {\n\tconst normal = normalize(cross(sub(v1, v3), sub(v2, v3)));\n\t// Note (Peter) use better rng source or deterministic ids in the future\n\tconst id = Math.floor(Math.random() * 100000000);\n\treturn {\n\t\tid,\n\t\tv1: v1,\n\t\tv2: v2,\n\t\tv3: v3,\n\t\tnormal,\n\t\tedges: [{\n\t\t\tanchor: v2,\n\t\t\ttestPoint: v3,\n\t\t\tv: normalize(sub(v1, v2)),\n\t\t\tlen: len(sub(v1, v2)),\n\t\t\tn: normalize(cross(sub(v1, v2), normal)),\n\t\t}, {\n\t\t\tanchor: v3,\n\t\t\ttestPoint: v1,\n\t\t\tv: normalize(sub(v2, v3)),\n\t\t\tlen: len(sub(v2, v3)),\n\t\t\tn: normalize(cross(sub(v2, v3), normal)),\n\t\t}, {\n\t\t\tanchor: v1,\n\t\t\ttestPoint: v2,\n\t\t\tv: normalize(sub(v3, v1)),\n\t\t\tlen: len(sub(v3, v1)),\n\t\t\tn: normalize(cross(sub(v3, v1), normal)),\n\t\t}]\n\t}\n}\n\nfunction rayIntersectsPlane(origin, v, planeLike) {\n\tconst projTowardsPlane = dot(planeLike.normal, v);\n\tif (Math.abs(projTowardsPlane) < EPSILON) return;\n\n\tconst newPlanePos = sub(planeLike.v1, origin);\n\tconst distToPlane = dot(newPlanePos, planeLike.normal);\n\treturn distToPlane / projTowardsPlane;\n}\n\nfunction coplanarPointInTriangle(pt, triangle, epsilon = 0) {\n\tfor (let e of triangle.edges) {\n\t\tconst trueSide = dot(sub(e.testPoint, e.anchor), e.n);\n\t\tconst testSide = dot(sub(pt, e.anchor), e.n);\n\t\tif (Math.sign(testSide) !== Math.sign(trueSide) && Math.abs(trueSide - testSide) >= epsilon) return false;\n\t}\n\treturn true;\n}\n\n// this function checks if a sphere hits a triangle from above or below\n// note we do NOT check whether sphere comes in through an edge or a vertex\nfunction sphereHitsTrianglePlane(origin, v, r, triangle) {\n\tconst { v1, normal } = triangle;\n\tconst sign = Math.sign(dot(sub(origin, v1), normal));\n\tconst newOrigin = sub(origin, scale(normal, r * sign));\n\n\tconst sphereHitsPlane = rayIntersectsPlane(newOrigin, v, triangle);\n\tif (!sphereHitsPlane) return;\n\n\tconst sphereProjectionOnPlane = add(scale(v, sphereHitsPlane), newOrigin);\n\tif (coplanarPointInTriangle(sphereProjectionOnPlane, triangle)) return sphereHitsPlane;\n\n\treturn;\n}\n\n// note we assume the sphere isn't already hitting the edge\nfunction sphereHitsLine(origin, v, r, lineLike) {\n\tconst newOrigin = sub(origin, lineLike.anchor);\n\tconst lNorm = lineLike.v;\n\tconst oo = dot(newOrigin, newOrigin);\n\tconst ov = dot(newOrigin, v);\n\tconst ol = dot(newOrigin, lNorm);\n\tconst vl = dot(v, lNorm);\n\tconst vv = dot(v, v);\n\tconst c = oo - ol * ol - r * r;\n\tconst b = 2 * (ov - ol * vl);\n\tconst a = vv - vl * vl;\n\n\tconst radicant = b*b - 4*a*c;\n\tif (radicant < 0) return;\n\n\tconst sqrtRad = Math.sqrt(radicant);\n\treturn {\n\t\ts1: (-b - sqrtRad) / (2 * a),\n\t\ts2: (-b + sqrtRad) / (2 * a),\n\t}\n}\n\n// note we assume the sphere isn't already hitting the edge\n// we also don't take care of the cases where the sphere hits an edge cap\nfunction sphereHitsEdge(origin, v, r, edgeLike) {\n\tconst sphereIntersectsLine = sphereHitsLine(origin, v, r, edgeLike);\n\tif (sphereIntersectsLine === undefined) return {};\n\n\tconst { s1, s2 } = sphereIntersectsLine;\n\n\tconst newOrigin = sub(origin, edgeLike.anchor);\n\n\tconst intersectionS1 = add(scale(v, s1), newOrigin);\n\tconst intersectionS2 = add(scale(v, s2), newOrigin);\n\n\tconst projS1 = dot(intersectionS1, edgeLike.v);\n\tconst projS2 = dot(intersectionS2, edgeLike.v);\n\n\tconst ret = { \n\t\ts1: { \n\t\t\tt: s1,\n\t\t\tn: sub(intersectionS1, scale(edgeLike.v, projS1)),\n\t\t}, \n\t\ts2: {\n\t\t\tt: s2,\n\t\t\tn: sub(intersectionS2, scale(edgeLike.v, projS2)),\n\t\t} \n\t};\n\n\tif (projS1 < 0 || projS1 > edgeLike.len) ret.s1 = undefined;\n\tif (projS2 < 0 || projS2 > edgeLike.len) ret.s2 = undefined;\n\n\treturn ret;\n}\n\nfunction sphereHitsPoint(origin, v, r, pointLike) {\n\tconst newPoint = sub(pointLike.anchor, origin);\n\tconst a = dot(v, v);\n\tconst b = -2 * dot(v, newPoint);\n\tconst c = dot(newPoint, newPoint) - r * r;\n\n\tconst radicant = b*b - 4*a*c;\n\tif (radicant < 0) return;\n\n\tconst sqrtRad = Math.sqrt(radicant);\n\treturn {\n\t\ts1: (-b - sqrtRad) / (2 * a),\n\t\ts2: (-b + sqrtRad) / (2 * a),\n\t}\n}\n\n// returns first valid point hit and its normal\n// TODO this function could probably be made more readable\nfunction sphereHitsTriangle(origin, v, r, triangle) {\n\tconst sphereIntersectsTriangle = sphereHitsTrianglePlane(origin, v, r, triangle);\n\n\tlet minT = 100000000;\n\tlet minN;\n\n\t// TODO make sure 0 is false is not a problem here\n\tif (sphereIntersectsTriangle !== undefined && sphereIntersectsTriangle > 0) {\n\t\tminT = sphereIntersectsTriangle;\n\t\tminN = triangle.normal;\n\t}\n\n\tfor (let e of triangle.edges) {\n\t\tconst sphereIntersectsEdge = sphereHitsEdge(origin, v, r, e);\n\t\tif (sphereIntersectsEdge.s1 !== undefined && sphereIntersectsEdge.s1.t >= 0 && sphereIntersectsEdge.s1.t < minT) {\n\t\t\tminT = sphereIntersectsEdge.s1.t;\n\t\t\tminN = normalize(sphereIntersectsEdge.s1.n);\n\t\t}\n\t\tif (sphereIntersectsEdge.s2 !== undefined && sphereIntersectsEdge.s2.t >= 0 && sphereIntersectsEdge.s2.t < minT) {\n\t\t\tminT = sphereIntersectsEdge.s2.t;\n\t\t\tminN = normalize(sphereIntersectsEdge.s2.n);\n\t\t}\n\n\t\tconst sphereIntersectsPoint = sphereHitsPoint(origin, v, r, e);\n\t\tif (sphereIntersectsPoint !== undefined && sphereIntersectsPoint.s1 >= 0 && sphereIntersectsPoint.s1 < minT) {\n\t\t\tconst moved = add(scale(v, sphereIntersectsPoint.s1), origin);\n\t\t\tminT = sphereIntersectsPoint.s1;\n\t\t\tminN = normalize(sub(moved, e.anchor));\n\t\t}\n\t\tif (sphereIntersectsPoint !== undefined && sphereIntersectsPoint.s2 >= 0 && sphereIntersectsPoint.s2 < minT) {\n\t\t\tconst moved = add(scale(v, sphereIntersectsPoint.s2), origin);\n\t\t\tminT = sphereIntersectsPoint.s2;\n\t\t\tminN = normalize(sub(moved, e.anchor));\n\t\t}\n\t}\n\n\tif (!minN) return;\n\treturn {\n\t\tt: minT,\n\t\tn: minN,\n\t}\n}\n\nfunction squaredDistToEdge(point, edgeLike) {\n\tconst newPoint = sub(point, edgeLike.anchor);\n\tlet proj = dot(newPoint, edgeLike.v);\n\n\tproj = Math.min(Math.max(0, proj), edgeLike.len);\n\n\tconst diff = sub(newPoint, scale(edgeLike.v, proj));\n\treturn {\n\t\tdist: dot(diff, diff),\n\t\tdir: normalize(diff),\n\t};\n}\n\nfunction squaredDistToTrianglePlane(point, triangle, epsilon = 0) {\n\tconst newPoint = sub(point, triangle.v1);\n\tconst proj = sub(newPoint, scale(triangle.normal, dot(newPoint, triangle.normal)));\n\tconst diff = sub(newPoint, proj);\n\n\tif (coplanarPointInTriangle(add(proj, triangle.v1), triangle, epsilon)) return {\n\t\tdist: dot(diff, diff),\n\t\tdir: normalize(diff),\n\t};\n\n\treturn;\n}\n\nfunction squaredDistToTriangle(point, triangle) {\n\tconst distToTri = squaredDistToTrianglePlane(point, triangle);\n\n\tconst distanceToEdge = triangle.edges.reduce((closest, e) => {\n\t\tconst res = squaredDistToEdge(point, e);\n\t\tif (!closest || res.dist < closest.dist) return res;\n\n\t\treturn closest;\n\t}, null);\n\t\n\t// TODO Peter is this really nessecary if there is a point on the plane shoudn't it always\n\t// be closer than projection to an edge?\n\tif (distToTri && (!distanceToEdge || distToTri.dist < distanceToEdge.dist)) return distToTri;\n\treturn distanceToEdge;\n}\n\nmodule.exports = {\n\tadd,\n\tsub,\n\tscale,\n\tdot,\n\tcross,\n\tvector,\n\tnormalize,\n\ttriangle,\n\trayIntersectsPlane,\n\tcoplanarPointInTriangle,\n\tsphereHitsTrianglePlane,\n\tsphereHitsLine,\n\tsphereHitsEdge,\n\tsphereHitsPoint,\n\tsphereHitsTriangle,\n\tsquaredDistToTriangle,\n\tsquaredDistToEdge,\n\tsquaredDistToTrianglePlane,\n}\n","const geom = require('./geometry/triangle');\nconst EPSILON = 0.0000;\n\nfunction calculateSlide(velocity, t, tMax, normal) {\n\tconst scaledV = geom.scale(velocity, tMax - t);\n\treturn geom.add(scaledV, geom.scale(normal, -geom.dot(scaledV, normal)));\n}\n\nfunction calculateSlide2(velocity, t, tMax, normal) {\n\tconst scaledV = geom.scale(velocity, tMax - t);\n\treturn geom.add(scaledV, geom.scale(normal, -Math.min(geom.dot(scaledV, normal), 0)));\n}\n\nfunction moveAndSlide(origin, radius, originalVelocity, triangles, stepSize = 1, depth = 3, kineticFriction = 0.5, totalNormalForce = { x: 0, y: 0, z: 0 }, totalFrictionForce = { x: 0, y: 0, z: 0 }) {\n\tif (depth === 0) return { newOrigin: origin, totalNormalForce, totalFrictionForce };\n\n\t// we may start very close to some triangles, if we do assume we are automatically hitting them\n\t// remove the part of our movement pointing that way right off of the bat\n\n\tlet updatedTotalNormalForce = totalNormalForce;\n\n\tconst { vectorsToProjectAgainst, triangleIds } = getTrianglesWithinDist(origin, triangles, radius + 1);\n\tconst velocity = vectorsToProjectAgainst.reduce((vel, normal) => {\n\t\tconst normalForceMag = -geom.dot(normal, vel);\n\t\tupdatedTotalNormalForce = geom.add(geom.scale(normal, normalForceMag), updatedTotalNormalForce);\n\t\treturn calculateSlide2(vel, 0, stepSize, normal);\n\t}, originalVelocity);\n\tconst filteredTriangles = triangles.filter(tri => !triangleIds.includes(tri.id));\n\t// now search for further collisions\n\n\tlet minT = 10000000000;\n\tlet minN;\n\n\tfor (let triangle of filteredTriangles) {\n\t\tconst intersection = geom.sphereHitsTriangle(origin, velocity,\n\t\t\tradius, triangle);\n\t\tif (intersection && intersection.t >= 0 && intersection.t < minT) {\n\t\t\tminN = intersection.n;\n\t\t\tminT = intersection.t;\n\t\t}\n\t}\n\n\tminT = Math.min(Math.max(minT - EPSILON, 0), stepSize);\n\n\tconst move = geom.add(origin, geom.scale(velocity, minT));\n\tconsole.log({ newOrigin: move, totalNormalForce: updatedTotalNormalForce, totalFrictionForce });\n\n\tif (!minN) return { newOrigin: move, totalNormalForce: updatedTotalNormalForce, totalFrictionForce };\n\n\tconst slide = calculateSlide(velocity, minT, stepSize, minN);\n\n\t// TODO I'm sure this part could be improved / moved\n\t// also test this\n\tconst normalForceMag = Math.abs(geom.dot(minN, velocity)) * (1 - minT);\n\tupdatedTotalNormalForce = geom.add(updatedTotalNormalForce, geom.scale(minN, normalForceMag));\n\n\tconst slideMag = Math.sqrt(geom.dot(slide, slide));\n\tconst frictionAmount = Math.max(slideMag - normalForceMag * kineticFriction, 0) / (slideMag === 0 ? 1 : slideMag);\n\tconst postFrictionSlide = geom.scale(slide, frictionAmount);\n\tconst updatedTotalFrictionForce = geom.add(\n\t\ttotalFrictionForce,\n\t\tgeom.scale(slide, -(1 - frictionAmount))\n\t);\n\n\treturn moveAndSlide(move, radius, postFrictionSlide, triangles, stepSize, depth - 1, kineticFriction, updatedTotalNormalForce, updatedTotalFrictionForce);\n}\n\nconst getTrianglesWithinDist = (origin, triangles, withinDist) => triangles.reduce(({ vectorsToProjectAgainst, triangleIds }, tri) => {\n\tlet ret = geom.squaredDistToTriangle(origin, tri);\n\tif (!ret) return {\n\t\tvectorsToProjectAgainst,\n\t\ttriangleIds,\n\t};\n\n\tconst { dist, dir } = ret;\n\t\n\tif (dist < withinDist * withinDist) {\n\t\ttriangleIds.push(tri.id);\n\t\t// gram schmit!!!!!!\n\t\tlet finalDir = dir;\n\t\tvectorsToProjectAgainst.forEach(vec => {\n\t\t\tconst proj = Math.min(geom.dot(finalDir, vec), 0);\n\t\t\tfinalDir = geom.add(finalDir, geom.scale(vec, -proj));\n\t\t});\n\t\tif (finalDir.x !== 0 || finalDir.y !== 0 || finalDir.z !== 0){\n\t\t\tvectorsToProjectAgainst.push(geom.normalize(finalDir));\t\n\t\t};\n\t}\n\n\treturn {\n\t\tvectorsToProjectAgainst,\n\t\ttriangleIds\n\t};\n}, {\n\tvectorsToProjectAgainst: [],\n\ttriangleIds: [],\n});\n\n// TODO this function could be wayyyy more efficient\nfunction calculateGravityDirection(origin, triangles, exclusionDist = 100) {\n\tconst { grav, _minDist } = triangles.reduce(({ grav, minDist }, tri) => {\n\t\tlet ret = geom.squaredDistToTriangle(origin, tri);\n\t\tif (!ret) return { grav, minDist };\n\n\t\tconst { dist, dir } = ret;\n\n\t\tif (dist > exclusionDist * exclusionDist || !dist) return { grav, minDist };\n\n\t\tif (dist > minDist) return { grav, minDist };\n\n\t\t/*const rayOccluded = triangles.reduce((hits, tri) => {\n\t\t\tif (!hits) return false;\n\n\t\t\t// this function with sphere radius 0 is a raycast\n\t\t\tconst intersection = geom.sphereHitsTrianglePlane(origin, dir, 0, tri);\n\t\t\tif (intersection && intersection < dist) return false;\n\n\t\t\treturn hits;\n\t\t});\n\n\t\tif (rayOccluded) return grav;*/\n\n\t\t//grav = geom.add(geom.scale(dir, 1.0/(1 + dist)), grav);\n\t\tgrav = dir;\n\n\t\treturn { grav, minDist: dist };\n\t}, { grav: geom.vector(0, 0, 0), minDist: 1000000 });\n\tif (grav.x === 0 && grav.y === 0 && grav.z === 0) return grav;\n\n\treturn geom.scale(geom.normalize(grav), -1);\n}\n\nmodule.exports = {\n\tcalculateSlide,\n\tmoveAndSlide,\n\tgeom,\n\tcalculateGravityDirection,\n}\n","function crapRand(seed) {\n\treturn (Math.sin(seed) + 1) / 2.0;\n}\n\nfunction generateAsteroid(THREE, radius) {\n\tconst geom = new THREE.SphereGeometry(radius, 10, 10);\n\n\tvertsToNeighborsMap = [];\n\tfor (let i = 0; i < geom.vertices.length; i+=1) {\n\t\tvertsToNeighborsMap.push({});\n\t\tlet scale = Math.random() * 1.2 + 0.4;\n\t\tscale *= scale * scale;\n\t\tgeom.vertices[i].set(\n\t\t\tgeom.vertices[i].x * scale,\n\t\t\tgeom.vertices[i].y * scale,\n\t\t\tgeom.vertices[i].z * scale);\n\t}\n\n\tfor (let f of geom.faces) {\n\t\tvertsToNeighborsMap[f.a][f.b] = true;\n\t\tvertsToNeighborsMap[f.a][f.c] = true;\n\t\tvertsToNeighborsMap[f.b][f.a] = true;\n\t\tvertsToNeighborsMap[f.b][f.c] = true;\n\t\tvertsToNeighborsMap[f.c][f.a] = true;\n\t\tvertsToNeighborsMap[f.c][f.b] = true;\n\t}\n\n\tconsole.log('vtN', vertsToNeighborsMap);\n\n\tfor (let j = 0; j < 3; j++) {\n\t\tfor (let i = 0; i < geom.vertices.length; i+=1) {\n\t\t\tconst neighbors = Object.keys(vertsToNeighborsMap[i]);\n\t\t\tlet avgLen = neighbors.reduce((sum, key) => {\n\t\t\t\treturn sum + geom.vertices[key].length();\n\t\t\t}, 0) / (neighbors.length === 0 ? 1 : neighbors.length);\n\t\t\tconsole.log(avgLen);\n\t\t\tgeom.vertices[i] = geom.vertices[i].normalize().multiplyScalar(avgLen);\n\t\t}\n\t}\n\n\tgeom.verticesNeedUpdate = true;\n\tgeom.computeVertexNormals();\n\treturn geom;\n}\n\nmodule.exports = {\n\tgenerateAsteroid,\n}","// calculate new orientation using an axis angle rotation\n// axis is the cross product of old down and new down and angle is assuming the shortest angle taken between them\nfunction calculateOrientationDeltaAxisAndAngle(oldDown, down) {\n  // TODO (Peter) can probably save a dot product down there b/c cross product mag is related to cos(theta)\n  const rawAxis = geom.cross(down, oldDown);\n  if (Math.abs(geom.dot(rawAxis, rawAxis)) > 0.0001) {\n    const axis = geom.normalize(rawAxis);\n    const angle = Math.acos(geom.dot(down, oldDown));\n    return { axis, angle };\n  }\n  // not large enough to warrant an orientation change\n  return;\n}\n\nconst ORIENTATION_DIRECTIONS = {\n  LEFT: 0,\n  FORWARD: 1,\n  DOWN: 2,\n}\n\nconst ORIENTATIONS = [\n  { x: 1, y: 0, z: 0 },\n  { x: 0, y: -1, z: 0 },\n  { x: 0, y: 0, z: 1 },\n];\n\n// TODO (Peter) replace the dependency on THREE.js for the axis angle rotations and quarternions\nfunction getOrientations(THREE, quaternion) {\n  return ORIENTATIONS.map(orientation => {\n    const threeOrientation = new THREE.Vector3(orientation.x, orientation.y, orientation.z);\n    threeOrientation.applyQuaternion(quaternion);\n    return threeOrientation;\n  })\n}\n\nfunction createOrientationController(THREE) {\n  const internalQuaternion = new THREE.Quaternion();\n  let internalDown = ORIENTATIONS[ORIENTATION_DIRECTIONS.DOWN];\n  return {\n    getQuaternion: () => internalQuaternion.clone().conjugate(),\n    update: down => {\n      const ret = calculateOrientationDeltaAxisAndAngle(\n        internalDown,\n        down\n      );\n      if (!ret) return;\n\n      const { axis, angle } = ret;\n      const threeAxis = new THREE.Vector3(axis.x, axis.y, axis.z);\n\n      const updateQuaternion = new THREE.Quaternion();\n      updateQuaternion.setFromAxisAngle(threeAxis, angle);\n\n      internalQuaternion.multiply(updateQuaternion);\n      internalDown = down;\n    },\n  }\n}\n\nmodule.exports = {\n  createOrientationController,\n  getOrientations,\n  ORIENTATION_DIRECTIONS,\n}\n","let closeRenderTarget;\nlet orthoCamera;\nlet orthoScene;\n\nfunction setup(THREE, width, height) {\n    closeRenderTarget = new THREE.WebGLRenderTarget(width, height, {});\n    orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);\n    orthoScene = new THREE.Scene();\n    const geometry = new THREE.PlaneGeometry( 2, 2 );\n    const material = new THREE.MeshBasicMaterial( {\n        map: closeRenderTarget.texture,\n        alphaMap: closeRenderTarget.texture,\n        side: THREE.DoubleSide,\n        transparent: true,\n    });\n    const plane = new THREE.Mesh( geometry, material );\n    orthoScene.add(plane);\n}\n\nfunction render(THREE, renderer, scene, originalCamera, distanceToPlayer) {\n    // should maybe use it's own renderer and camera and not hijack others\n    /*scene.background = new THREE.Color(0x000000);\n    originalCamera.near = 0.1;\n    originalCamera.far = distanceToPlayer;\n    originalCamera.updateProjectionMatrix();\n    renderer.render(scene, originalCamera, closeRenderTarget);\n    originalCamera.near = distanceToPlayer;\n    originalCamera.far = 1000;\n    originalCamera.updateProjectionMatrix();\n    scene.background = new THREE.Color(0xffffff);*/\n    renderer.render(scene, originalCamera);\n    /*renderer.autoClear = false;\n    renderer.render(orthoScene, orthoCamera);\n    renderer.autoClear = true;*/\n}\n\nmodule.exports = {\n    setup,\n    render,\n}\n","const phys = require('./physics.js');\nconst geom = require('./geometry/triangle.js');\n\nconst asteroid = require('./game/asteroid.js');\nconst orientationController = require('./controllers/OrientationController');\n\nconst transparentOccluder = require('./camera/transparentOccluder');\n\nmodule.exports = {\n\tphys,\n\tgeom,\n\tasteroid,\n\torientationController,\n\ttransparentOccluder,\n}\n"]}
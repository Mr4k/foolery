{"version":3,"sources":["geometry/triangle.js","physics.js","game/asteroid.js","controllers/OrientationController.js","index.js"],"names":["EPSILON","vector","x","y","z","sub","v1","v2","add","scale","s","dot","cross","len","Math","sqrt","normalize","triangle","v3","normal","edges","anchor","testPoint","v","n","rayIntersectsPlane","origin","planeLike","projTowardsPlane","abs","distToPlane","coplanarPointInTriangle","pt","epsilon","e","trueSide","testSide","sign","sphereHitsTrianglePlane","r","newOrigin","sphereHitsPlane","sphereHitsLine","lineLike","lNorm","oo","ov","ol","vl","b","a","radicant","sqrtRad","s1","s2","sphereHitsEdge","edgeLike","sphereIntersectsLine","undefined","intersectionS1","intersectionS2","projS1","projS2","ret","t","sphereHitsPoint","pointLike","newPoint","sphereHitsTriangle","sphereIntersectsTriangle","minN","minT","sphereIntersectsEdge","sphereIntersectsPoint","moved","squaredDistToEdge","point","proj","min","max","diff","dist","dir","squaredDistToTrianglePlane","squaredDistToTriangle","distToTri","distanceToEdge","reduce","closest","res","module","exports","geom","require","calculateSlide","velocity","tMax","scaledV","moveAndSlide","radius","triangles","stepSize","depth","kineticFriction","totalNormalForce","totalFrictionForce","intersection","console","log","move","slide","normalForceMag","updatedTotalNormalForce","slideMag","frictionAmount","calculateGravityDirection","exclusionDist","tri","grav","minDist","_minDist","crapRand","seed","sin","generateAsteroid","THREE","SphereGeometry","vertsToNeighborsMap","i","vertices","length","push","random","set","faces","f","c","j","neighbors","Object","keys","avgLen","sum","key","multiplyScalar","verticesNeedUpdate","computeVertexNormals","calculateOrientationDeltaAxisAndAngle","oldDown","down","rawAxis","axis","angle","acos","ORIENTATION_DIRECTIONS","LEFT","FORWARD","DOWN","createOrientationController","stepAmount","orientations","getOrientation","orientation","update","forEach","index","threeOrientationVector","Vector3","applyAxisAngle","phys","asteroid","orientationController"],"mappings":"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","file":"index.js","sourceRoot":"../js","sourcesContent":["const EPSILON = 0.0001;\n\nfunction vector(x, y, z) {\n\treturn {\n\t\tx: x,\n\t\ty: y,\n\t\tz: z,\n\t}\n}\n\nfunction sub(v1, v2) {\n\treturn {\n\t\tx:v1.x-v2.x,\n\t\ty:v1.y-v2.y,\n\t\tz:v1.z-v2.z,\n\t}\n}\n\nfunction add(v1, v2) {\n\treturn {\n\t\tx:v1.x+v2.x,\n\t\ty:v1.y+v2.y,\n\t\tz:v1.z+v2.z,\n\t}\n}\n\nfunction scale(v1, s) {\n\treturn {\n\t\tx: v1.x * s,\n\t\ty: v1.y * s,\n\t\tz: v1.z * s,\n\t}\n}\n\nfunction dot(v1, v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfunction cross(v1, v2) {\n\treturn {\n\t\tx: v1.y*v2.z - v1.z*v2.y,\n\t\ty: v1.z*v2.x - v1.x*v2.z,\n\t\tz: v1.x*v2.y - v1.y*v2.x,\n\t}\n}\n\nfunction len(v1) {\n\treturn Math.sqrt(dot(v1, v1));\n}\n\nfunction normalize(v1) {\n\tconst len = Math.sqrt(dot(v1, v1));\n\treturn {\n\t\tx: v1.x / len,\n\t\ty: v1.y / len,\n\t\tz: v1.z / len,\n\t}\n}\n\n// TODO make this function more efficient\nfunction triangle(v1, v2, v3) {\n\tconst normal = normalize(cross(sub(v1, v3), sub(v2, v3)));\n\treturn {\n\t\tv1: v1,\n\t\tv2: v2,\n\t\tv3: v3,\n\t\tnormal,\n\t\tedges: [{\n\t\t\tanchor: v2,\n\t\t\ttestPoint: v3,\n\t\t\tv: normalize(sub(v1, v2)),\n\t\t\tlen: len(sub(v1, v2)),\n\t\t\tn: normalize(cross(sub(v1, v2), normal)),\n\t\t}, {\n\t\t\tanchor: v3,\n\t\t\ttestPoint: v1,\n\t\t\tv: normalize(sub(v2, v3)),\n\t\t\tlen: len(sub(v2, v3)),\n\t\t\tn: normalize(cross(sub(v2, v3), normal)),\n\t\t}, {\n\t\t\tanchor: v1,\n\t\t\ttestPoint: v2,\n\t\t\tv: normalize(sub(v3, v1)),\n\t\t\tlen: len(sub(v3, v1)),\n\t\t\tn: normalize(cross(sub(v3, v1), normal)),\n\t\t}]\n\t}\n}\n\nfunction rayIntersectsPlane(origin, v, planeLike) {\n\tconst projTowardsPlane = dot(planeLike.normal, v);\n\tif (Math.abs(projTowardsPlane) < EPSILON) return;\n\n\tconst newPlanePos = sub(planeLike.v1, origin);\n\tconst distToPlane = dot(newPlanePos, planeLike.normal);\n\treturn distToPlane / projTowardsPlane;\n}\n\nfunction coplanarPointInTriangle(pt, triangle, epsilon = 0) {\n\tfor (let e of triangle.edges) {\n\t\tconst trueSide = dot(sub(e.testPoint, e.anchor), e.n);\n\t\tconst testSide = dot(sub(pt, e.anchor), e.n);\n\t\tif (Math.sign(testSide) !== Math.sign(trueSide) && Math.abs(trueSide - testSide) >= epsilon) return false;\n\t}\n\treturn true;\n}\n\n// this function checks if a sphere hits a triangle from above or below\n// note we do NOT check whether sphere comes in through an edge or a vertex\nfunction sphereHitsTrianglePlane(origin, v, r, triangle) {\n\tconst { v1, normal } = triangle;\n\tconst sign = Math.sign(dot(sub(origin, v1), normal));\n\tconst newOrigin = sub(origin, scale(normal, r * sign));\n\n\tconst sphereHitsPlane = rayIntersectsPlane(newOrigin, v, triangle);\n\tif (!sphereHitsPlane) return;\n\n\tconst sphereProjectionOnPlane = add(scale(v, sphereHitsPlane), newOrigin);\n\tif (coplanarPointInTriangle(sphereProjectionOnPlane, triangle)) return sphereHitsPlane;\n\n\treturn;\n}\n\n// note we assume the sphere isn't already hitting the edge\nfunction sphereHitsLine(origin, v, r, lineLike) {\n\tconst newOrigin = sub(origin, lineLike.anchor);\n\tconst lNorm = lineLike.v;\n\tconst oo = dot(newOrigin, newOrigin);\n\tconst ov = dot(newOrigin, v);\n\tconst ol = dot(newOrigin, lNorm);\n\tconst vl = dot(v, lNorm);\n\tconst vv = dot(v, v);\n\tconst c = oo - ol * ol - r * r;\n\tconst b = 2 * (ov - ol * vl);\n\tconst a = vv - vl * vl;\n\n\tconst radicant = b*b - 4*a*c;\n\tif (radicant < 0) return;\n\n\tconst sqrtRad = Math.sqrt(radicant);\n\treturn {\n\t\ts1: (-b - sqrtRad) / (2 * a),\n\t\ts2: (-b + sqrtRad) / (2 * a),\n\t}\n}\n\n// note we assume the sphere isn't already hitting the edge\n// we also don't take care of the cases where the sphere hits an edge cap\nfunction sphereHitsEdge(origin, v, r, edgeLike) {\n\tconst sphereIntersectsLine = sphereHitsLine(origin, v, r, edgeLike);\n\tif (sphereIntersectsLine === undefined) return {};\n\n\tconst { s1, s2 } = sphereIntersectsLine;\n\n\tconst newOrigin = sub(origin, edgeLike.anchor);\n\n\tconst intersectionS1 = add(scale(v, s1), newOrigin);\n\tconst intersectionS2 = add(scale(v, s2), newOrigin);\n\n\tconst projS1 = dot(intersectionS1, edgeLike.v);\n\tconst projS2 = dot(intersectionS2, edgeLike.v);\n\n\tconst ret = { \n\t\ts1: { \n\t\t\tt: s1,\n\t\t\tn: sub(intersectionS1, scale(edgeLike.v, projS1)),\n\t\t}, \n\t\ts2: {\n\t\t\tt: s2,\n\t\t\tn: sub(intersectionS2, scale(edgeLike.v, projS2)),\n\t\t} \n\t};\n\n\tif (projS1 < 0 || projS1 > edgeLike.len) ret.s1 = undefined;\n\tif (projS2 < 0 || projS2 > edgeLike.len) ret.s2 = undefined;\n\n\treturn ret;\n}\n\nfunction sphereHitsPoint(origin, v, r, pointLike) {\n\tconst newPoint = sub(pointLike.anchor, origin);\n\tconst a = dot(v, v);\n\tconst b = -2 * dot(v, newPoint);\n\tconst c = dot(newPoint, newPoint) - r * r;\n\n\tconst radicant = b*b - 4*a*c;\n\tif (radicant < 0) return;\n\n\tconst sqrtRad = Math.sqrt(radicant);\n\treturn {\n\t\ts1: (-b - sqrtRad) / (2 * a),\n\t\ts2: (-b + sqrtRad) / (2 * a),\n\t}\n}\n\n// returns first valid point hit and its normal\n// TODO this function could probably be made more readable\nfunction sphereHitsTriangle(origin, v, r, triangle) {\n\tconst sphereIntersectsTriangle = sphereHitsTrianglePlane(origin, v, r, triangle);\n\n\tlet minT = 100000000;\n\tlet minN;\n\n\t// TODO make sure 0 is false is not a problem here\n\tif (sphereIntersectsTriangle !== undefined && sphereIntersectsTriangle > 0) {\n\t\tminT = sphereIntersectsTriangle;\n\t\tminN = triangle.normal;\n\t}\n\n\tfor (let e of triangle.edges) {\n\t\tconst sphereIntersectsEdge = sphereHitsEdge(origin, v, r, e);\n\t\tif (sphereIntersectsEdge.s1 !== undefined && sphereIntersectsEdge.s1.t >= 0 && sphereIntersectsEdge.s1.t < minT) {\n\t\t\tminT = sphereIntersectsEdge.s1.t;\n\t\t\tminN = normalize(sphereIntersectsEdge.s1.n);\n\t\t}\n\t\tif (sphereIntersectsEdge.s2 !== undefined && sphereIntersectsEdge.s2.t >= 0 && sphereIntersectsEdge.s2.t < minT) {\n\t\t\tminT = sphereIntersectsEdge.s2.t;\n\t\t\tminN = normalize(sphereIntersectsEdge.s2.n);\n\t\t}\n\n\t\tconst sphereIntersectsPoint = sphereHitsPoint(origin, v, r, e);\n\t\tif (sphereIntersectsPoint !== undefined && sphereIntersectsPoint.s1 >= 0 && sphereIntersectsPoint.s1 < minT) {\n\t\t\tconst moved = add(scale(v, sphereIntersectsPoint.s1), origin);\n\t\t\tminT = sphereIntersectsPoint.s1;\n\t\t\tminN = normalize(sub(moved, e.anchor));\n\t\t}\n\t\tif (sphereIntersectsPoint !== undefined && sphereIntersectsPoint.s2 >= 0 && sphereIntersectsPoint.s2 < minT) {\n\t\t\tconst moved = add(scale(v, sphereIntersectsPoint.s2), origin);\n\t\t\tminT = sphereIntersectsPoint.s2;\n\t\t\tminN = normalize(sub(moved, e.anchor));\n\t\t}\n\t}\n\n\tif (!minN) return;\n\treturn {\n\t\tt: minT,\n\t\tn: minN,\n\t}\n}\n\nfunction squaredDistToEdge(point, edgeLike) {\n\tconst newPoint = sub(point, edgeLike.anchor);\n\tlet proj = dot(newPoint, edgeLike.v);\n\n\tproj = Math.min(Math.max(0, proj), edgeLike.len);\n\n\tconst diff = sub(newPoint, scale(edgeLike.v, proj));\n\treturn {\n\t\tdist: dot(diff, diff),\n\t\tdir: normalize(diff),\n\t};\n}\n\nfunction squaredDistToTrianglePlane(point, triangle, epsilon = 0) {\n\tconst newPoint = sub(point, triangle.v1);\n\tconst proj = sub(newPoint, scale(triangle.normal, dot(newPoint, triangle.normal)));\n\tconst diff = sub(newPoint, proj);\n\n\tif (coplanarPointInTriangle(add(proj, triangle.v1), triangle, epsilon)) return {\n\t\tdist: dot(diff, diff),\n\t\tdir: normalize(diff),\n\t};\n\n\treturn;\n}\n\nfunction squaredDistToTriangle(point, triangle) {\n\tconst distToTri = squaredDistToTrianglePlane(point, triangle);\n\n\tconst distanceToEdge = triangle.edges.reduce((closest, e) => {\n\t\tconst res = squaredDistToEdge(point, e);\n\t\tif (!closest || res.dist < closest.dist) return res;\n\n\t\treturn closest;\n\t}, null);\n\t\n\t// TODO Peter is this really nessecary if there is a point on the plane shoudn't it always\n\t// be closer than projection to an edge?\n\tif (distToTri && (!distanceToEdge || distToTri.dist < distanceToEdge.dist)) return distToTri;\n\treturn distanceToEdge;\n}\n\nmodule.exports = {\n\tadd,\n\tsub,\n\tscale,\n\tdot,\n\tcross,\n\tvector,\n\tnormalize,\n\ttriangle,\n\trayIntersectsPlane,\n\tcoplanarPointInTriangle,\n\tsphereHitsTrianglePlane,\n\tsphereHitsLine,\n\tsphereHitsEdge,\n\tsphereHitsPoint,\n\tsphereHitsTriangle,\n\tsquaredDistToTriangle,\n\tsquaredDistToEdge,\n\tsquaredDistToTrianglePlane,\n}\n","const geom = require('./geometry/triangle');\nconst EPSILON = 0.0001;\n\nfunction calculateSlide(velocity, t, tMax, normal) {\n\tconst scaledV = geom.scale(velocity, tMax - t);\n\treturn geom.add(scaledV, geom.scale(normal, -geom.dot(scaledV, normal)));\n}\n\nfunction moveAndSlide(origin, radius, velocity, triangles, stepSize = 1, depth = 3, kineticFriction = 0.5, totalNormalForce = { x: 0, y: 0, z: 0 }, totalFrictionForce = { x: 0, y: 0, z: 0 }) {\n\tif (depth === 0) return { newOrigin: origin, totalNormalForce, totalFrictionForce };\n\n\tlet minT = 10000000000;\n\tlet minN;\n\n\tfor (let triangle of triangles) {\n\t\tconst intersection = geom.sphereHitsTriangle(origin, velocity,\n\t\t\tradius, triangle);\n\t\tif (intersection && Math.abs(intersection.t) < EPSILON * 10) console.log(intersection.t);\n\t\tif (intersection && intersection.t >= 0 && intersection.t < minT) {\n\t\t\tminN = intersection.n;\n\t\t\tminT = intersection.t;\n\t\t}\n\t}\n\n\tminT = Math.min(Math.max(minT - EPSILON, 0), stepSize);\n\tconsole.log(minT, 'minT');\n\n\tconst move = geom.add(origin, geom.scale(velocity, minT));\n\n\tif (!minN) return { newOrigin: move, totalNormalForce, totalFrictionForce };\n\n\tconst slide = calculateSlide(velocity, minT, stepSize, minN);\n\n\t// TODO I'm sure this part could be improved / moved\n\t// also test this\n\tconst normalForceMag = Math.abs(geom.dot(minN, velocity)) * (1 - minT);\n\tconst updatedTotalNormalForce = geom.add(totalNormalForce, geom.scale(minN, normalForceMag));\n\n\tconst slideMag = Math.sqrt(geom.dot(slide, slide));\n\tconst frictionAmount = Math.max(slideMag - normalForceMag * kineticFriction, 0) / (slideMag === 0 ? 1 : slideMag);\n\tconst postFrictionSlide = geom.scale(slide, frictionAmount);\n\tconst updatedTotalFrictionForce = geom.add(\n\t\ttotalFrictionForce,\n\t\tgeom.scale(slide, -(1 - frictionAmount))\n\t);\n\n\treturn moveAndSlide(move, radius, postFrictionSlide, triangles, stepSize, depth - 1, kineticFriction, updatedTotalNormalForce, updatedTotalFrictionForce);\n}\n\n// TODO this function could be wayyyy more efficient\nfunction calculateGravityDirection(origin, triangles, exclusionDist = 100) {\n\tconst { grav, _minDist } = triangles.reduce(({ grav, minDist }, tri) => {\n\t\tlet ret = geom.squaredDistToTriangle(origin, tri);\n\t\tif (!ret) return { grav, minDist };\n\n\t\tconst { dist, dir } = ret;\n\n\t\tif (dist > exclusionDist * exclusionDist || !dist) return { grav, minDist };\n\n\t\tif (dist > minDist) return { grav, minDist };\n\n\t\t/*const rayOccluded = triangles.reduce((hits, tri) => {\n\t\t\tif (!hits) return false;\n\n\t\t\t// this function with sphere radius 0 is a raycast\n\t\t\tconst intersection = geom.sphereHitsTrianglePlane(origin, dir, 0, tri);\n\t\t\tif (intersection && intersection < dist) return false;\n\n\t\t\treturn hits;\n\t\t});\n\n\t\tif (rayOccluded) return grav;*/\n\n\t\t//grav = geom.add(geom.scale(dir, 1.0/(1 + dist)), grav);\n\t\tgrav = dir;\n\n\t\treturn { grav, minDist: dist };\n\t}, { grav: geom.vector(0, 0, 0), minDist: 1000000 });\n\tif (grav.x === 0 && grav.y === 0 && grav.z === 0) return grav;\n\n\treturn geom.scale(geom.normalize(grav), -1);\n}\n\nmodule.exports = {\n\tcalculateSlide,\n\tmoveAndSlide,\n\tgeom,\n\tcalculateGravityDirection,\n}\n","function crapRand(seed) {\n\treturn (Math.sin(seed) + 1) / 2.0;\n}\n\nfunction generateAsteroid(THREE, radius) {\n\tconst geom = new THREE.SphereGeometry(radius, 10, 10);\n\n\tvertsToNeighborsMap = [];\n\tfor (let i = 0; i < geom.vertices.length; i+=1) {\n\t\tvertsToNeighborsMap.push({});\n\t\tlet scale = Math.random() * 1.2 + 0.4;\n\t\tscale *= scale * scale;\n\t\tgeom.vertices[i].set(\n\t\t\tgeom.vertices[i].x * scale,\n\t\t\tgeom.vertices[i].y * scale,\n\t\t\tgeom.vertices[i].z * scale);\n\t}\n\n\tfor (let f of geom.faces) {\n\t\tvertsToNeighborsMap[f.a][f.b] = true;\n\t\tvertsToNeighborsMap[f.a][f.c] = true;\n\t\tvertsToNeighborsMap[f.b][f.a] = true;\n\t\tvertsToNeighborsMap[f.b][f.c] = true;\n\t\tvertsToNeighborsMap[f.c][f.a] = true;\n\t\tvertsToNeighborsMap[f.c][f.b] = true;\n\t}\n\n\tconsole.log('vtN', vertsToNeighborsMap);\n\n\tfor (let j = 0; j < 3; j++) {\n\t\tfor (let i = 0; i < geom.vertices.length; i+=1) {\n\t\t\tconst neighbors = Object.keys(vertsToNeighborsMap[i]);\n\t\t\tlet avgLen = neighbors.reduce((sum, key) => {\n\t\t\t\treturn sum + geom.vertices[key].length();\n\t\t\t}, 0) / (neighbors.length === 0 ? 1 : neighbors.length);\n\t\t\tconsole.log(avgLen);\n\t\t\tgeom.vertices[i] = geom.vertices[i].normalize().multiplyScalar(avgLen);\n\t\t}\n\t}\n\n\tgeom.verticesNeedUpdate = true;\n\tgeom.computeVertexNormals();\n\treturn geom;\n}\n\nmodule.exports = {\n\tgenerateAsteroid,\n}","// calculate new orientation using an axis angle rotation\n// axis is the cross product of old down and new down and angle is assuming the shortest angle taken between them\nfunction calculateOrientationDeltaAxisAndAngle(oldDown, down) {\n  // TODO (Peter) can probably save a dot product down there b/c cross product mag is related to cos(theta)\n  const rawAxis = geom.cross(down, oldDown);\n  if (Math.abs(geom.dot(rawAxis, rawAxis)) > 0.0001) {\n    const axis = geom.normalize(rawAxis);\n    const angle = Math.acos(geom.dot(down, oldDown));\n    return { axis, angle };\n  }\n  // not large enough to warrant an orientation change\n  return;\n}\n\nconst ORIENTATION_DIRECTIONS = {\n  LEFT: 0,\n  FORWARD: 1,\n  DOWN: 2,\n}\n\n// TODO (Peter) replace the dependency on THREE.js for the axis angle rotations\nfunction createOrientationController(THREE, stepAmount = 1) {\n  const orientations = [\n    { x: 1, y: 0, z: 0 },\n    { x: 0, y: -1, z: 0 },\n    { x: 0, y: 0, z: 1 },\n  ];\n  return {\n    getOrientation: orientation => orientations[orientation],\n    update: down => {\n      const ret = calculateOrientationDeltaAxisAndAngle(\n        orientations[ORIENTATION_DIRECTIONS.DOWN],\n        down\n      );\n      if (!ret) return;\n\n      const { axis, angle } = ret;\n      orientations.forEach((orientation, index) => {\n        const threeOrientationVector = new THREE.Vector3(\n          orientation.x,\n          orientation.y,\n          orientation.z);\n\t\t\t\tthreeOrientationVector.applyAxisAngle(axis, -angle * stepAmount);\n\t\t\t\torientations[index] = {\n          x: threeOrientationVector.x,\n          y: threeOrientationVector.y,\n          z: threeOrientationVector.z,\n        };\n      });\n    },\n  }\n}\n\nmodule.exports = {\n  createOrientationController,\n  ORIENTATION_DIRECTIONS,\n}\n","const phys = require('./physics.js');\nconst geom = require('./geometry/triangle.js');\n\nconst asteroid = require('./game/asteroid.js');\nconst orientationController = require('./controllers/OrientationController');\n\nmodule.exports = {\n\tphys,\n\tgeom,\n\tasteroid,\n\torientationController,\n}"]}